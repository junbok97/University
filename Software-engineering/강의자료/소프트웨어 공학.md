유스케이스 실체화 (usecase realization )  : 유스케이스 내부를 분석. 유스케이스를 실현하기 위해서 어떤 객체들이 필요하고 이들의 상호작용을 도출 하는것이 필요하다. 산출물로는 클래스 다이어그램과 순차 다이어그램이 있다.

분석단계 : 문제를 파악하는 단계



설계단계 : 문제를 해결하는 해결책을 찾아내는 단계 분석단계에서 고려하지 않았던 사용자 인터페이스 부분과 영속성 등의 문제를 보다 상세하게 고려하여 기존 클래스들을 보완, 특히 보안성 신뢰성 가용성과 같은 품질속성 고려하고 유틸리티와 같은 기술적 클래스들을 식별하고 개발



소프트웨어 아키텍쳐 : 상위수준에서 소프트웨어를 설계하는 기본 틀. 보안성 성능과 같은 품질 속성은 아키텍쳐 결정에 많은 영향을 준다. 어떤 품질속성에 우선순위를 두느냐에 따라 아키텍쳐가 달라진다.



계층 아키텍쳐 (layered architecture) : 아키텍쳐 시스템을 여러 계층으로 나누어 설계. 한레이어는 다른 레이어에 서비스를 제공하는 식으로 구현. 3-계층 아키텍쳐로 많이 구현. 

* 프리젠테이션 계층(presentation layer)  : 시스템과 외부사이의 소통을 담당하는 레이어. 화면을 조작하고 사용자와의 소통을 수행
* 비지니스 로직계층 (business logic layer) : 프리젠테이션 레이어를 통해 들어온 입력들을 가지고 실제로 일을 하는것. 애플리케이션 로직을 실행
* 데이터 접근 계층 (data access layer) : 비지니스 로직 계층에서 받은 데이터를 저장하기 위한 계층

계층 아키텍처에서 보통 계층 N은 N+1계층에 서비스를 제공하는 역할을 수행. 

presentation layer에서 business logic layer로 의존관계 business logic 에서 data access layer로 의존되게 설계

동일한 계층을 다르게 구현한다 할지라도 각 계층에 동일한 인터페이스를 제공한다면 상호 대체가 가능.

모든 계층을 동일한 개발자가 모두 개발할 필요가 없으며 다른 개발자가 개발한 계층을 구입하여 사용할수있다

파이프&필터 : 시스템을 구성하는 각 컴포넌트를 필터라 부르며 필터간의 연결 관계를 파이프라 부른다. 필터는 자신의 출력 결과를 받는 필터가 누구인지 알지 못한다.

블랙보드 : 중앙에있는 블랙보드(저장소)를 통해서 컴포넌트들은 상호작용한다. 컴포넌트들이 직접적으로 서로 소통하지 않기 때문에 컴포넌트 재사용이 용이하고 새로운 서비스를 제공하기 위한 컴포넌트를 쉽게 추가하는 것이 가능. 하지만 저장소의 구조가 변환다면 컴포넌트들도 변경되어야할 가능성이 높다.

MVC : 시스템의 컨포넌트를 3가지 유형으로 구분. 모델 컨트롤러 뷰 모델은 애플리케이션의 핵심이 되는 데이터를 제공하는 컴포넌트이며 뷰와 컨트롤러 컴포넌트에 영향을 받지 않도록 설계한다. 뷰는 모델을 입력받아 사용자에게 보여주는 인터페이스 컴포넌트이고 컨트롤러는 사용자로부터의 요청을 처리하여 모델을 생성하고 필요한 로직을 실행하고 적절한 뷰를 선정하는 책임도 수행한다. 사용자는 오직 컨트롤러를 통해서만 시스템과 상호작용한다.스프링 프레임워크가 대표적인 MVC이다

마이크로 서비스 아키텍쳐 (microservice) : 대형 소프트웨어 프로젝트의 기등들을 작고 독립적이며 느슨하게 결합 된 모듈로 분해하여 서비스를 제공하는 아키텍쳐 결합력이 약하다 각각의 서비스들은 DB를 공유되지않고 분리되어 있는것이 특징 한 서비스에 문제가 생겨도 다른서비스에 직접적인 영향을 미치지 않고 변경이 용이하며 개별 서비스 단위의 배포가 가능하다. 해당 서비스의 개선과 수정 작업이 다른 서비스의 이해 당사자들과 독립적이다. 부하가 집중되는 특정 서비스를 위해 전체 애플리케이션을 스케일 아웃할 필요가 없다.

모노리식(monolithic)아키텍쳐 : 마이크로 서비스 아키텍쳐와 반대. 한프로젝트의 덩치가 너무 커져서 어플리케이션 구동시간이 늘어나고 빌드,배포시간도 길어진다. 조그마한 수정사항이 있어도 전체를 다시 빌드하고 배포를 해야한다. 많은양의 코드가 몰려있어 개발자가 모두를 이해 할 수 없고 유지보수도 힘들며 일부분의 오류가 전체에 영향을 미친다. 기능별로 알맞는 기술 언어 프레임워크를 선택하기가 까다롭다.

패키지간에는 연관관계



응집도(Cohesion)와 결합도(Coupling)

관련되있는것들이 뭉쳐있는것이 응집도이고 결합도는 모듈간의 관계를 나타낸다. 응집도는 높게 결합도는 낮게 설계하는것이 기본 원칙 응집도가 높아지면 결합도는 낮아진다. 반대로 결합도가 높아지면 응집도가 낮아진다. 

결합도 = 모듈간의 관계. 응집도 = 개별 모듈,함수들을 어떻게 설계하냐

한 기능을 수행하는 모듈의 응집도 > 여러기능을 수행하는 모듈의 응집도

cohesion is the measure of the strength of functional relatedness of elements within a routine

element - Anypiece of code that accomplishes some task or defines some data

Ensuring good coshesion is the best way to minimise coupling

데이터로 연결 or 실행순서로 연결

* Functional 기능적 : 기능 하나만을 수행 다른 응집도들은 여러 기능을 수행 기능적 응집도를 갖는 모듈은 모듈의 어떤 코드 부분을 제거하면 기능을 제대로 수행하지 못한다.
* Sequential 순차적 : 코드들이 서로 입력과 출력으로 맞물려 있으면 순차적. 뒤의 코드는 앞의 코드의 출력이 필요.
* Communicational 통신적 : 동일한 데이터를 사용하여 코드를 수행하면 통신적.
* --------Modularity Line--------
* Procedural 절차적 : 실행순서로만 연결되어있을때.
* Temporal 시간적 : 기능적으론 관련이없지만 코드가 실행되는 시점이 같을때
* Logical 논리적 : 논리적으로 연결되어 있을 경우
* Coincidental 우연적 : 아무 관련이 없는 코드들이 한 모듈안에 구성되어 있을때



Functional Cohesion

* A FC routine contains elements that all contribute to the execution of one and only one problem related task
  * Compute Cosine of Angle
  * Verify User password
  * Calculate Mortgage Repayment
  * Compute Rocket Trajectory
* Normally coupled, functionally cohesive routines have Advantages
  * Easy to maintain
  * Easy to understand
  * Black box (내부 구현을 몰라도 재사용 가능)



Sequential Cohesion

* A SC routine is one whose elements are involved in activities such that output data from one serves as input data to the next
  * input : Gross profit(punds), Total Costs(punds) -> Calculate Net Profit -> Convert to Dollars  -> output : Netprofit(dollars)
  * 순이익을 계산하고 파운드를 달러로 변환하는 두가지 조건을 충족한 상황에서만 사용가능
  * 두개의 기능이 결합되어있기 때문에 순이익만 계산할수도 파운드와 달러로만 변환 할수도 없음
  * 순이익을 계산하는 모듈과 파운드를 달러로 변환하는 모듈 두가지로 나누면 문제 해결 가능



Communicational Cohesion

* A CmC routine is one whose elements contribute to activities that use the same input data
* 동일한 데이터를 사용. 기능들이 순차적으로 관련있는게아니고 독립적으로 사용한다.
  * input : Customer Account Number -> Determine Customer Details -> output : Customer Balance, Customer Name
  * 고객의 계좌번호 하나를 가지고 고객의 이름과 계좌의 잔액을 확인가능
  * 두 조건을 만족하는 상황에서만 사용가능.
  * 고객의 잔액을 확인하는 모듈과 고객의 이름을 알아내는 모듈 두개로 분리하여 문제해결가능



Procedural Cohesion

- A PC is one whose elements are involved in differnet activities but the activities are sequential
- 실행순서로 묶여있다. 데이터로 묶여있지 않기때문에 기능적으로 밀접한 관계는 아니다. 독립실행가능
  - input : radar info -> calculate trajectory -> activate alarms -> trajectory specification
  - 궤도정보를 가지고 궤도계산을 한 후 알람 활성화
  - 궤도계산의 출력이 알람을 울리는 입력으로 가지 않았기때문에 순차적이아닌 절차적.
  - 알람활성화가 궤도계산이 반드시 필요한것이 아니기때문 다른 기능후에 알람을 울려도 되기때문
  - 마찬가지로 두개의 모듈로 분리하여 사용가능 아니면 두가지 조건모두 충족하는 상황에서만 사용가능



Temporal Cohesion

* A TC routine is one whose elements are involved in activities that are related in time
* 서로 관련은 없는 기능들이 실행되는 시점만 같은 경우
* 문제점은 하나만 초기화하고 싶을때 문제가 발생. 나머지 것들도 초기화 되기 때문



Logical Cohesion

- A LC routine is one whose elements contribute to activities of the same general category in which the activities to be executed are selected from outside the routine
- 경우에 따라 다른 기능을 수행할수있게 플래그 변수를 input으로 전달받아 외부에서 선택하여 실행할수 있게함(switch문 or if문)
- flag값의 의미를 외부에서 알아야만 사용가능. 또한 새로운 기능을 넣거나 flag 값에 따라 실행되는 코드가 바뀐다고 한다면 이 모듈을 사용한 모든 모듈들도 변경해야함.
- flag 값마다 실행되는 것들을 개별적으로 분리
- 제어결합도



Coincidental Cohesion

- A CC routine is one whose elements contribute to activities with no meaningful relationship to one another, and the activity to be executed is selected from outside the routine
- 전혀 상관없는 기능들이 묶여있는것
- dollars <-> found / kms <-> miles
- 여러기능들을 분리시켜 기능마다 하나의 모듈로 만들면 문제해결



Coupling 결합도

- Minimise coupling make routines as independent as possible

- Low coupling -> well-partitioned system

- No routine should have to worry about the internal details of another

  Classes of Coupling

  * Normal	Good(low)
    * Data 데이터
    * Stamp 스탬프
    * Control 제어
  * ---------------Modularity Line-------
  * Common 공통
  * Content   내용   Poor(high)



Normal Coupling - Data, Stamp, Control

* A모듈이 B모듈을 호출할때 X라는 데이터를 B모듈이 받아 출력값 Y를 모듈 A에게 전달해주는것
* Data Coupling
  * Two routines are data coupled if
    * They communicate by parameters
    * Each paramether is an elementary piece of dat
    * a
    * A와 B모듈이 주고받는 데이터가 구조체가 아니고 변수로만 상호작용
* Stamp Coupling
  * Two normally coupled routines are stamp coupled if
    * One passes the other a composite piece of data
    * Data with meaningful internal structure
    * A와 B모듈이 주고받는 데이터중 하나가 구조체
  * May be necessary at times
    * Do not pass records containing many fileds when only a few of those fileds are needed
    * 구조체로 필요하지 않는 데이터까지 넘어간다
    * 전혀 상관없는 데이터 필드의 변화가 실제 사용하는 모듈들을 새로 컴파일하여 목적파일을 만들어주어야한다.
* Control Coupling
  * Two routines are control coupled if one passes the other a piece of information intended to control the internal logic of another
  * 내부로직을 결정하는 flag 값이 존재하여 flag 값에 의해 모듈이 결정되는것. 데이터가 연산하는데 사용되지 않고 로직을 결정하는것 내부로직을 알아야하는 단점 flag 값의 의미가 달라지면 알아야함
* Common Coupling
  * Two (or more) routines are common coipled if they refer to the same golbal data area
  * 전역변수를 사용할때
  * 문제가 발생하면 전역변수를 사용하는 모듈들을 확인해야함
* Content Coupling
  * Difficult to Implement in High Level Languages



Cyclomatic Complexity

소프트웨어 복잡도

* 높은 복잡도를 가지는 프로그램은 신뢰성 테스트 비용 유지보수성 측면에서 좋지 않는 결과를 가져오기 때문이다.
* 복잡도가 높으면 이해하기 어렵고 유지보수하기 힘들기때문 프로그램을 제어 흐름 그래프로 변환 후에 구함
* if while for || && +1 +1



SOLID

SRP(Single Responsibility Principle) - 단일 책임 원칙

- 클래스나 모듈은 단 하나의 책임만을 가지도록 설계해야 한다는 의미
- 책임은 해야만 하는 것 or 클래스가 변경해야 하는 이유

OCP(Open Closed Principle) - 개방 폐쇄 원칙

- 기존의 코드를 변경하지 않으면서 새로운 기능을 추가할 수 있도록 설계하는 원칙
- 클래스는 변화의 단위

LSP(Liskov Substitution Principle) - 리스코프의 대입 원칙

- 일반화 관계를 적절하게 사용했는지를 점검하는 원칙
- 일봔화 관계는 슈퍼 클래스가 제공하는 오퍼레이션과 파생클래스에서 제공하는 오퍼레이션 간에는 행위적으로 일관성으로 있도록 설계가 되어야 한다는 의미
- 둘 사이에 일반화 관계가 존재하면 슈퍼클래스의 인스턴스 대신에 파생 클래스의 인스턴스로 대체하여도 의미가 변하지 않는다
- 행위 일관성 : 슈퍼클래스의 선조건(후조건)을 만족된다면 파생 클래스의 선조건(후조건)이 만족되어야 한다 

ISP(Interface Segregation Principle) - 인터페이스 분리 원칙

- Clients should not be forced to depend upon interfaces that they do not use
- 인터페이스를 클라이언트에 특화되도록 분리시키라는게 설계 원칙 (큰인터페이스 -> 작은 인터페이스)
- 클라이언트의 관점에서 클라이언트 자신이 이용하지 않는 기능에는 영향을 받지 않아야 한다는 내용이 담겨 있다.
- 외부 라이브러리로 주어져 변경할 수 없다면 Adapter 디자인 패턴 사용

DIP(Dependency Inversion Principle) -의존성 역전 원칙

- 상위 모듈은 하위 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화 된 것에 의존해야 한다
- 추상화 된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화 된 것에 의존해야한다.
- 의존 관계를 맺을 때 변화하기 쉬운 것 또는 변화가 자주 되는것보다는 변화하기가 어려운 것, 변화가 거의 되지 않는 것에 의존하라는 원칙이다.
- 정책, 전력과 같은 어떤 큰 흐름이나 개념 같은 추상적인 것은 변하기 어려운 것에 해당하고 구체적인 방식, 사물 등과 같은 것은 변하기 쉬운 것에 해당한다.
- 추상적인 것들을 표현하는 수단으로 추상 클래스와 인터페이스가 있다.
- 어떤 클래스가 도움을 받을 때는 구체적인 클래스보다는 인터페이스나 추상 클래스에 의존관계를 맺도록 설계해야한다.

소프트웨어 테스팅 목적

- 결함 발견
- 품질과 잔존 위험(residual risk)에 대한 정보 제공
- 소프트웨어가 오작동이 발생할 위험(risk)를 줄여야 한다
- 위험 : 발생확률 * 발생했을 때 끼치는 손실
- 소프트웨어 테스팅은 위험에서 발생 확률을 줄이는 작업
- ISO/IEC/IEEE 29119 소프트웨어 테스팅 국제 표준

정적 테스팅

- 프로그램 실행을 하지 않고 프로그램 코드나 산출물 결함을 찾는 활동
- IEE 1024[리뷰]
  - 관리 리뷰(Management Review)
  - 기술 리뷰(Technical Review)
  - 인스펙션(Inspection)
  - 워크쓰루(walk-through)
  - 감사(Audit)

동적 테스팅

- 컴퓨터 결함을 발견할 의도로 프로그램이나 시스템을 실행하는 과정(Meyers)
- 테스트 케이스(입력/기대 결과) 필요. 입력을 하고 나온 실행결과 기대결과와 같으면 pass 다르면 fail
- 테스트 대상이 되는것이 test item
- test oracle
  - 생성기능 : 각 테스트에 대해 예상 또는 기대되는 결과를 생성하여 제공하는 기능
  - 평가기능 : 예상 또는 기대 결과와 실제로 프로그램을 실행하여 얻어진 결과를 비교하여 테스트가 통과되었는지를 판단하는 기능

소프트웨어 테스팅 용어

- Error
  - 부정확환 결과를 야기하는 개발자의 행위이다
  - 사용자의 요구사항을 잘목파악하거나 type이나 프로그래밍 언어의 문법을 잘못 이해하여 코딩하는 경우에 발생
- Fault(결함)
  - 프로그램 기능을 제대로 수행하지 못하게 하는 프로그램의 흠
    - 잘못된 정보를 반영하는 경우(commission) : 안 해야할 일을 하는 경우
    - 올바른 정보를 빠뜨리는 경우(omission) : 해야할 일을 안하는 경우
    - 알고리즘 결함 : 알고리즘 결함은 잘못된 프로그램 경로를 수행하도록 하는 제어 흐름과 관련된 결함이나 대상이 되는 프로그램의 외부와 통신과 관련된 인터페이스 결함 및 잘못된 자료 구조의 사용으로 인한 결함 : 할일을 올바르지 않게 하는 경우
  - 프로그램 코드에서 문제를 일으키는 정적인 부분
- Failure(오작동)
  - 프로그램의 실행 결과와 기대 결과와의 (관찰가능한)차이를 말한다
  - 프로그램이 명세와는 다르게 동작하는 것이 외부에서 관찰되는 상황이다

RIP 모델

- 프로그램에 결함이 있을 때 오작동이 발생하는 조건
- 도달성 조건 (Reachability condition) : 프로그램의 결함이 있는 부분을 실행하여야 한다
- 감염 조건 (Infection condition) : 결함 부분을 실행하여 부정확한 상태(에러상태)를 유발하여야 한다. 여기에서 프로그램 변수가 가지고 있는 값과 프로그램 카운터(다음에 실행할 문장)가 프로그램 상태를 규정한다. 부정확한 상태는 프로그램 변수의 값이 해당 변수에 대해 기대되는 값과 다르거나 다음에 실행할 문장이 올바른 프로그램을 실행했을 때와 다른 경우이다. 결함이 있는 곳을 실행했을때 원하는 변수 값이 나오지 않아야 한다는 뜻. 
- 전달 조건 (Propagation condition) : 부정확한 상태가 부정확한 출력을 유발해야 한다.

완전한 테스트 (Exhaustive Test)

- 모든 입력조건 조합에 대하여 테스트한다는 의미
- 테스트 한계
  - 테스트는 오류가 없음을 보여주지 않는다
  - 언제 테스트를 종료 할 것인가?
  - 테스트 완료 기준



동적 테스트 설계 기법

- 명세기반 테스트 (Specification-Based)
  - 출력 인터페이스 정보나 명세정보를 이용하여 테스트 케이스를 설계
  - 블랙박스 테스팅
- 구조기반 테스트 (Structure-Based)
  - 프로그램 코드 로직정보를 이용하여 테스트 케이스 설계
  - 화이트박스 테스팅

- 경험기반 테스트 (Experience-Based)

테스트 베이시스 (test basis) : 테스트 케이스를 만드는데 사용하는 정보

- 명세기반 테스트 : 요구사항 명세
- 구조기반 테스트 : 코드 또는 로직

커버리지 분석

- 테스팅이 얼마나 충분하게 이루어졌는지를 분석
- 테스트 커버리지 아이템은 테스트 케이스에 의해 포함되거나 실행될 필요가 있는 명세나 프로그램에 있는항목
- 커버리지 계산 = 테스트 케이스에 의해 실행된 테스트 커버리지 아이템 수 / 전체 테스트 커버리지 아이템 수
- 테스트 완료 기준으로 사용

누락된 요구사항 검출 : 요구사항 명세서를 요구사항을 추가한 후에 실행이 되지 않은 부분을 실행할 수 있는 테스트 케이스를 추가한다.

누락된 테스트 검출 : 실행되지 않은 부분을 실행할 수 있는 테스트 케이스를 추가한다.

의도하지 않은 기능 검출 : 프로그램에서 제거한다.

데드(dead) 코드 검출 : 프로그램에서 제거한다

활성화 되지 않은 코드(deactivated code) 검출 : 현 시스템에서는 사용되지 않으나 특정 상황에서는 필요한 코드임을 보인다.

경험기반 테스팅

- 테스터의 경험이나 지식 및 직관을 기반으로 테스트 케이스를 설계하는 방법
- 오류 추정(error guessing)은 대표적인 경험 기반 테스트 설계 기술이다 오류추정은 과거의 유사한 프로그램을 테스트 했던 경험이나 테스터의 직관을 바탕으로 일반적으로 발생할 수 있는 오작동의 원인이나 문제가 될 만한 영역 등을 추정하여 테스트 케이스를 설계하는 방법
- 오류 추정은 테스트 케이스를 설계하는 특별한 규칙이나 가이드라인이 없으며 독단적으로 사용되기 보다는 명세 기반 테스트 테스팅 등에 의해 검출되는 오류 유형들을 보완하기 위해 사용



테스트 레벨

- 단위 테스트
- 통합 테스트
- 시스템 테스트
- 인수 테스트 (사용자가 테스트 나머지 3개는 개발자가)

단위 테스트

- 테스트 하네스(Harness) = 테스트 드라이버 + 테스트 스텁(테스트용 가짜 모듈)
- 드라이버 : 테스트 대상 컴포넌트를 호출하는 테스트용 임시 컴포넌트
- 테스트 스텁 : 테스트 대상 컴포넌트에 의해 호출되는 컴포넌트를 대신하는 테스트용 컴포넌트
- 실제로직을 구현하지 않고 미리 정해진 출력 결과를 단순하게 반환
- JUnit 테스트 프레임워크 / Mockito

통합 테스트

- 통합(intergration)테스트는 컴포넌트를 통합하는 과정에서 수행되는 테스트이다. 컴포넌트 테스트는 개별적인 모듈/컴포넌트의 기능이 올바르게 수행되었는지를 테스트하는 반면에 통합 테스트에서는 컴포넌트 간의 상호 연동이 올바르게 수행되는지를 검사
- 빅뱅 통합 : 모든 컴포넌트를 한번에 통합 후 테스팅
- 상향식 통합 : 컴포넌트를 점진적으로 통합 하여 테스팅

시스템 테스팅

- 통합 테스트가 완료된 후에 완전한 시스템에 대해 시스템 명세에 따라 개발되었는지를 검증하기 위해 수행하는 테스팅
- 기능 측면뿐만 아니라 신뢰성(reliability), 보안성(security), 성능(performance), 사용성(usability), 우지보수성(maintainability), 호환성)compatibility), 이식성(portability)등과 같은 비기능적인 요구사항을 시스템이 만족하는지도 검증

인수 테스팅

- 실제 사용자가 시스템을 사용하는 방식은 개발자가 시스템을 테스트 할 때 가정했던 방식과 차이가 존재
- 따라서 인수 테스트에서 개발자에 의해 수행된 테스트에 의해 발견되지 못한 결함을 발견할 수 있다.

- 인수 테스트의 주 목적은 결함을 검출하는 것이 아니라 시스템을 인수 받을 수 있는지를 고객의 입장에서 평가
  - 알파 테스트는 사용자에 의해 테스트가 수행되지만 개발자 환경에서 통제된 상태로 수행된다
  - 베타 테스트는 소프트웨어를 일정 수의 사용자들에게 사용하게 하고 피드백을 받는다 보통 베타 테스트에서는 개발자가 참여하지 않는다

소프트웨어 품질 속성 ISO 25010

- 기능 테스팅
  - 기능적 타당성 (functional suitability) : 요구되는 기능을 만족시키는 능력
  - 수행 효율성 (performance efficiency) : 적절한 자원의 사용 및 적정한 반응시간 정도
  - 호환성 (compatibility) : 다른 시스템과의 상호 연동능력, 동일한 하드웨어나 소프트웨어 환경을 공유하면서 요구되는 기능을 제공하는 능력
  - 사용성 (usability) : 특정 사용 맥락에서 특정 사용자가 얼마나 효과적이고 효율적으로 만족스럽게 특정 목표를 달성할수 있도록 소프트웨어 제품이 사용될 수 있는 정도
  - 신뢰성 (reliability) : 특정 조건에서 특정 기간동안 특정 기능을 수행하는 소프트웨어의 능력
- 비기능 테스팅
  - 보안성 (sercurity) : 인가되지 않은 사용자나 시스템에 의해 데이터나 정보가 읽혀지거나 수정되지 않는정도, 인가된 사람이나 시스템이 데이터나 정보를 접근하는 것을 거부하지 않는 정도
  - 유지보수성 (maintainability) : 쇼프트웨어 변경의 용이성 정도
  - 이식성 (portability) : 한 플랫폼에서 다른 플랫폼으로 이전 될 수 있는 소프트웨어의 능력\

테스트 타입 (유형)

![image-20210611211959309](C:\Users\junbok\AppData\Roaming\Typora\typora-user-images\image-20210611211959309.png)

![image-20210611212002333](C:\Users\junbok\AppData\Roaming\Typora\typora-user-images\image-20210611212002333.png)

성능 테스팅의 종류

- 부하 테스팅 (load testing) : 부하를 계속 증가시키면서 시스템의 임계점을 찾는것. 이 테스팅을 통해 병목 지점을 찾고 병목 현상을 제거하는 과정을 반복
- 스트레스 테스팅 (stress testing) : 시스템 처리 능력 이상의 부하, 즉 임계점 이상의 부하를 가하여 비정상적인 상황에서의 처리를 테스트
- 스파이크 테스팅 (spike testing) : 짧은 시간에 사용자가 몰려올 떄 시스템의 반응을 측정
- 내구성 테스팅 (endurance tseting / soak testing) : 오랜 시간동안 시스템에 높은 부하를 가하여 시스템의 반응을 파악



리그레션 테스팅과 리테스팅

- 프로그램 변경 후에 수행하는 테스팅
- 리그레션 테스팅
  - 프로그램 변경 후에 기존의 기능이 영향을 받았는지 테스팅
- 리테스팅
  - 프로그램 오류 수정 후에 오류가 제대로 수정되었는지 확인하는 테스팅
  - 오류를 발견한 테스트케이스를 재실행



명세기반 테스트 케이스 설계

ISO29119 Test basis

Specification-Based (명세기반 설계방식)

- Equivalence Partitioning (동등 분할 방식) ECP

  - 테스트의 기반

  - 프로그램의 입력/출력 영역을 몇 개의 동등 클래스라 불리는 영역으로 분할하여 각 클래스로부터 대표 값을 선택하여 테스트 케이스 이용

  - 동등 클래스는 시스템에 의해 동일하게 처리되고 같은 출력 결과를 생산하는 입력 조건 또는 입력 데이터 값들의 모임

    - 각 동등 클래스로부터 선정된 입력 값에 의하여 오류가 발견되면 클래스에 속한 다른 값들에 의해서도 동일한 오류가 발견
    - 만약 각 동등 클래스로부터 선정된 입력 값에 의하여 오류가 발견되지 못한다면 클래스에 속한 다른 값들에 의해서도 오류가 발견 되지 않아야 함

    동등 클래스 분할 규칙

    - 동등 분할 테스팅에서는 테스트 케이스를 설계하기 위하여 입력이나 출력 영역을 유요한 영역과 유요하지 않은 영역으로 분할한뒤 영역에서 임의의 값을 선정
    - 유효한 입력 : 정상적으로 처리된 입력
    - 유효하지 않은 입력 : 정상적으로 처리 되지 않는 입력
    - 유효한 출력 : 명세에 기술된 출력
    - 유효하지 않은 출력 : 명세에 기술되지 않은 출력

    ISO/IEC/IEEE 29119

    - One-to-One 동등 분할
      - 각 입력/출력 분할로부터 하나의 테스트 케이스를 유도
      - 입력/출력 영억을 분할한 클래스들과 테스트 케이스간 일대일 관계를 명시적으로 보여준다.
    - 최소화 동등 분할
      - 하나의 테스트 케이스와 하나의 분할된 클래스를 명시적으로 연결한 One-to-One 동등 분할과는 달리 이 방법은 하나의 테스트 케이스에 가능한 많은 분할들을 포함되도록 한다
      - 최소화 방식 테스트 케이스는 오류가 발생하는 경우를 놓칠수도 있다

- Classification Tree Method
- Boundary Value Analysis (경계값 분석)
  - 소프트웨어 오류는 보통 입력 영역의 경계에서 발생하는 경향이 있다
  - 경계값 분석은 입출력영역의 경계 근처에 있는 값들을 이용하여 테스트 케이스를 설계하는 방법이다.
  - 입출력 영역을 여러 클래스로 분할하고 경계값들을 선정
  - 도메인 에러 (domain error)
    - 입력이 실행해야 하는 경로가 아닌 다른 잘못된 경로를 실행
    - BVA를 포함한 도메인 테스트는 도메인 에어를 효과적으로 검출
  - 계산 에러(computation error)
    - 올바른 경로를 실행하지만 잘못된 계산을 실행
  - 2-value BVA : 경계 값과 경계 외부에 있는 경계와 가장 가까운 값을 선정
  - 3-value BVA : 경계 값과 경계내부와 외부에서 경계에 가장 가까운 값을 선정

테스트 케이스를 구성할 때 동등 분할 테스팅과 같이 식별된 경계값에 대해 하나의 테스트 케이스를 구성하는 일대일 방식이나 하나의 테스트 케이스에 여러 개의 경계값을 포함하는 최소화 방식을 사용할 수 있다.

Structure-Based (구조기반 설계방식) - 코드

Experience-Based (경험기반설계)



결정표 테스팅 (decision Table)

- 입력 조건들의 다양한 논리적 관계에 따라 테스트 아이템의 행위가 결정될 때 유용하게 이용할 수 있는 명세 기반 테스트 케이스 설계 기법

구조 기반 테스트 (Structure-Based)

- Statement Testing (문장 테스팅)
- Branch Testing (분기 테스팅)
- Decision Testing (결정 테스팅)



문장 테스팅

- 테스트하려는 프로그램 내의 모든 문장들을 적어도 한번 이상 실행하도록 요규하는 테스트 케이스 설계 방법
- 가장 기본적인 구조기반/화이트 박스 테스트
- 100%의 문장 커버리지 = 프로그램 내의 모든 문장들을 적어도 한번씩 실행했다
- 문장 커버리지 = 테스트 케이스에 의해 실행된 문장 (of executed statements) / 전체 문장 수 (of total statements)
- 테스트 커버리지 아이템 : 문장
- 절차
  - 테스트 대상 프로그램에 해당하는 제어 흐름 그래프를 작성한다
  - 모든 실행 가능한 기본 블록들을 지나가는 프로그램 경로 집합을 식별한다
  - 프로그램 경로 집합에 있는 각 프로그램 경로에 대해 다음을 수행한다
    - 경로를 실행하는 입력 데이터를 식별한다
    - 명세등으로부터 해당입력에 대한 기대 출력을 식별한다
- 모든 프로그램에 대해서 100% 문장 커버리지는 달성할 수 없다
  - 실행 불가능한 블록이 존재하는 경우가 있기 때문

분기 테스팅

- 분기 테스팅은 프로그램을 제어 흐름 그래프로 변환했을 때 제어 흐름 그래프의 모든 간선을 최소한 한번은 실행하는 테스트 케이스가 테스트집합에 포함되도록 요구
- 테스트 커버리지 아이템 : 분기 또는 간선
- 문장 버커리지를 만족하면 분기 커버리지를 만족하는가?
  - 모든 노드들이 샐행된것이 모든 간선들이 실행된건 아니기 때문에 NO
- 분기 커버리지를 만족하면 문장 커버리지를 만족하는가?
  - 모든 간선들이 실행되면 모든 노드들이 샐행되었기 때문에 YES

결정 테스팅

- 프로그램의 모든 결정들에 대해 모든 가능한 결과를 가져올 수 있도록 테스트 케이스 집합을 설계한다
- 각 결정이 가질 수 있는 경우는 true 와 false 이므로 프로그램의 각 결정에 대해 true 와 false 가 산출될 수 있도록 하는 테스트 케이스가 최소한 1개 포함되어 있어야 한다

- 테스트 커버리지 아이템 : 결정
- 조건 (condition) : NOT을 제외한 AND, OR 등의 논리 연산자가 없는 조건 기본 조건식을 그냥 조건 또는 claus라고도 한다
- 결정 (decision) : 조건이나 조건이 AND,OR등의 논리 연산자로 관계되어 있음
- Decision Testing vs Branch Testing
  - ISTQB에서는 결정 테스팅과 분기 테스팅을 구별하지 않는다
  - ISO/IEC/IEEE 29119 에서는 결정 테스팅과 분기 테스팅을 달리 정의한다 분기 테스팅은 프로그램 제어 흐름 그래프로 표현했을때 제어 흐름 그래프상의 분기들을 최소한 한번은 실행되기를 요구한다
  - 결정문이 분기를 가지지 않은 경우에는 분기 테스팅의 테스트케이스 집합과 결정 테스팅의 테스트 케이스 집합이 동일하지 않을수 있다

기본 경로 테스팅 (Basis Path Testing)

- ISO/IEC/IEEE 29119에서는 언급하지 않지만 많은 곳에서 언급되는 테스팅 방법
- 기본 경로 테스팅은 McCabe가 제안한 테스팅 방법 (순환복잡도 제시)
  - 기본 경로 테스팅은 말그대로 프로그램으로부터 기본경로를 구하여 이를 실행하는 테스트 케이스를 설계하는 방법
  - 기본경로들을 사용하여 프로그램 나머지 경로들을 만들 수 있다 즉 기본경로집합은 프로그램상에 존재하는 어떤 경로도 그 경로가 기본경로집합에 속하지 않는 한 기본경로집합에 있는 경로들을 선형적으로 조합하여 표현할 수 있다
  - 따라서 기본 경로들은 선형적으로 독립되었다
- 간선 벡터 (Edge Vector)
- 기본 경로 구하기 : Baseline 방법
  - 테스트 대상 프로그램의 제어흐름 그래프를 작성한다
  - 제어흐름 그래프에서 베이스라인이 되는 프로그램 경로를 선정한다
  - 두번째 경로를 생성하기 위해 베이스라인 경로를 따라 만난 첫 번째 결정문의 출력을 변경하고 베이스라인의 나머지 결정들의 값은 가능한 변경하지 않는다
  - 경로를 생성한는중에 베이스라인 경로에 없는 새로운 결정문을 만난다면 임의의 결정 출력 값을 선정한다
  - 세번째 경로는 첫번째 결정문의 베이스라인 경로와 동일하게 하고 두번째 결정문의 값을 변경하고 첫번째 및 나머지 결정문의 값을 가능한 베이스라인과 동일하게 한다
  - 위 과정을 베이스라인의 모든 결정문에 대해 반복
  - 두번째 기본 경로를 베이스라인 경로로 하여 위 과정을 반복한다
  - 위 과정을 프로그램의 모든 결정문이 처리될때 까지 반복한다
- 순환 복잡도 (Cyclomatic Complexity)
  - 프로그램 기본 경로의 개수는 McCabe가 발표한 순환복잡도를 통해 알 수 있다
  - 순환복잡도는 프로그램을 제어 흐름 그래프로 변환후에 알수있다
    - E-N+2 (E: 간선들의 개수 N:노드들의 개수)
    - P+1(P: 술어(또는 분기)노드의 개수)
    - 영역의 개수 + 1

순환복잡도와 기본경로의 수는 같다

